#include <iostream>
#include <stdint.h>
#include <cassert>

struct Vector2D
{
public:
	/*
		Constructors
	*/
    Vector2D( );
	Vector2D( const float x, const float y );
	Vector2D( const Vector3D& );

	/*
		Utility
	*/
	static float DotProduct( const Vector2D& first,
									  const Vector2D& second );
	static Vector2D CrossProduct( const Vector2D& first,
											    const Vector2D& second );

	void Normalize( );
	float Length( ) const;
	float LengthSq( ) const;

public:
    // Arithmetic operators
	Vector2D operator+( const Vector2D& ) const;
	Vector2D operator-( const Vector2D& ) const;
	Vector2D operator*( const Vector2D& ) const;
	Vector2D operator/( const Vector2D& ) const;
	Vector2D operator*( float ) const;
	Vector2D operator/( float ) const;

	// Unary operators
	Vector2D operator+( ) const;
	Vector2D operator-( ) const;

	// Compound assignment operators
	Vector2D& operator+=( const Vector2D& );
	Vector2D& operator-=( const Vector2D& );
	Vector2D& operator*=( const float );
	Vector2D& operator/=( const float );

	// Comparison operators
	bool operator==( const Vector2D& ) const;
	bool operator!=( const Vector2D& ) const;

	float& operator[]( const int32_t );
	float operator[]( const int32_t ) const;
	
public:
	/* Vector2D components */
	float x;
	float y;
};

Vector2D::Vector2D( const float x, const float y ) :
	x( x ), y( y )
{
}

Vector2D::Vector2D( const Vector3D& v ) :
	x( v.x ), y( v.y )
{
}

Vector2D Vector2D::operator+( const Vector2D& rhs ) const
{
#ifdef TGON_SUPPORT_SIMD
#else
	return Vector2D( x+rhs.x, y+rhs.y );
#endif
}

Vector2D Vector2D::operator-( const Vector2D& rhs ) const
{
#ifdef TGON_SUPPORT_SIMD
#else
	return Vector2D( x-rhs.x, y-rhs.y );
#endif
}

Vector2D Vector2D::operator*( const Vector2D& rhs ) const
{
#ifdef TGON_SUPPORT_SIMD
#else
	return Vector2D( x*rhs.x, y*rhs.y );
#endif
}

Vector2D Vector2D::operator/( const Vector2D& rhs ) const
{
#ifdef TGON_SUPPORT_SIMD
#else
	return Vector2D( x/rhs.x, y/rhs.y );
#endif
}

Vector2D Vector2D::operator*( const float scalar ) const
{
#ifdef TGON_SUPPORT_SIMD
#else
	return Vector2D( x*scalar, y*scalar );
#endif
}

Vector2D Vector2D::operator/( const float scalar ) const
{
#ifdef TGON_SUPPORT_SIMD
#else
	const float inv = 1.0f / scalar;

	return Vector2D( x*inv, y*inv );
#endif
}

Vector2D& Vector2D::operator+=( const Vector2D& v ) 
{
	x += v.x;
	y += v.y;

	return *this;
}

Vector2D& Vector2D::operator-=( const Vector2D& v ) 
{
	x -= v.x;
	y -= v.y;

	return *this;
}

Vector2D& Vector2D::operator*=( const float scalar ) 
{
	x *= scalar;
	y *= scalar;

	return *this;
}

Vector2D& Vector2D::operator/=( const float scalar )
{
	const float inv = 1.0f / scalar;

	x *= inv;
	y *= inv;

	return *this;
}

bool Vector2D::operator==( const Vector2D& v ) const 
{
#ifdef TGON_SUPPORT_SIMD
#else
	return ( x == v.x && y == v.y );
#endif
}

bool Vector2D::operator!=( const Vector2D& v ) const 
{
#ifdef TGON_SUPPORT_SIMD
#else
	return ( x != v.x || y != v.y );
#endif
}

float& Vector2D::operator[]( const int32_t index ) 
{
	assert( index < 2 && "Vector2D index out of range" );

#ifdef TGON_SUPPORT_SIMD
#else
	return	( index == 0 ) ? x : y;
#endif
}

float Vector2D::operator[]( const int32_t index ) const 
{
	assert( index < 2 && "Vector2D index out of range" );

#ifdef TGON_SUPPORT_SIMD
#else
	return	( index == 0 ) ? x : y;
#endif
}

float Vector2D::DotProduct(
		const Vector2D& first,
		const Vector2D& second ) 
{
#ifdef TGON_SUPPORT_SIMD
#else
	return ( first.x*second.x ) + ( first.y*second.y );
#endif
}

float Vector2D::Length( ) const 
{
#ifdef TGON_SUPPORT_SIMD
#else
	return std::sqrt( x*x + y*y );
#endif
}


float Vector2D::LengthSq( ) const 
{
	const float length( this->Length( ));

	return length*length;
}


void Vector2D::Normalize( ) 
{
#ifdef TGON_SUPPORT_SIMD

#else
	const float inv = ( 1.0f / this->Length( ));

	x *= inv;
	y *= inv;
#endif
}